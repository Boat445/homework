<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8" />
<title>Three.js – Finn + Model4 + Jake Cel Shader + Light Control</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>html,body{height:100%;margin:0} canvas{display:block}</style>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
</head>
<body>
<script>
  // Scene / Camera / Renderer
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
  camera.position.set(0, 1.2, 3);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x333333, 0.6); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(3,5,2); dir.castShadow = true; scene.add(dir);

  // GUI for Light Control
  const gui = new dat.GUI();
  const lightFolder = gui.addFolder("Light Settings");
  const lightParams = {
    hemiColor: hemi.color.getHex(),
    hemiIntensity: hemi.intensity,
    dirColor: dir.color.getHex(),
    dirIntensity: dir.intensity,
    dirX: dir.position.x,
    dirY: dir.position.y,
    dirZ: dir.position.z
  };
  lightFolder.addColor(lightParams, 'hemiColor').name("Hemisphere Color").onChange(val=>hemi.color.setHex(val));
  lightFolder.add(lightParams, 'hemiIntensity',0,2).name("Hemisphere Intensity").onChange(val=>hemi.intensity=val);
  lightFolder.addColor(lightParams, 'dirColor').name("Directional Color").onChange(val=>dir.color.setHex(val));
  lightFolder.add(lightParams, 'dirIntensity',0,5).name("Directional Intensity").onChange(val=>dir.intensity=val);
  lightFolder.add(lightParams, 'dirX',-10,10).name("Dir X").onChange(val=>dir.position.x=val);
  lightFolder.add(lightParams, 'dirY',0,10).name("Dir Y").onChange(val=>dir.position.y=val);
  lightFolder.add(lightParams, 'dirZ',-10,10).name("Dir Z").onChange(val=>dir.position.z=val);
  lightFolder.open();

  // Ground
  const ground = new THREE.Mesh(
    new THREE.PlaneBufferGeometry(10,10),
    new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.95, metalness:0.0})
  );
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  // Environment map
  const cubeUrls = [
    'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
    'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
    'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg',
    'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg',
    'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
    'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg'
  ];
  const envMap = new THREE.CubeTextureLoader().load(cubeUrls, () => {
    scene.background = envMap;
    scene.environment = envMap;
  });
  envMap.encoding = THREE.sRGBEncoding;

  // Sphere with standard PBR
  const geo = new THREE.SphereBufferGeometry(0.65, 64, 64);
  const mat = new THREE.MeshStandardMaterial({
    color:0xffffff, metalness:0.9, roughness:0.1, envMap: envMap, envMapIntensity:1.0
  });
  const ball = new THREE.Mesh(geo, mat);
  ball.position.y = 0.7; ball.castShadow = true; scene.add(ball);

  // Clock & Mixer
  const clock = new THREE.Clock(); let mixer = null;

  // GLTF Loader
  const gltfLoader = new THREE.GLTFLoader();

  // Load poramet
  gltfLoader.load('https://boat445.github.io/homework/poramet.glb', gltf=>{
    const model = gltf.scene || gltf.scenes[0];
    model.traverse(node=>{
      if(node.isMesh){
        node.castShadow=true; node.receiveShadow=true;
        if(node.material && (node.material.isMeshStandardMaterial||node.material.isMeshPhysicalMaterial)){
          node.material.envMap = envMap;
          node.material.needsUpdate = true;
        }
      }
    });
    model.position.set(30,5,0);
    model.scale.set(2,2,2);
    scene.add(model);
  });

  gltfLoader.load('https://boat445.github.io/homework/finn_the_human.glb', gltf=>{
  const model = gltf.scene || gltf.scenes[0];
  model.traverse(node=>{
    if(node.isMesh){
      node.castShadow=true; node.receiveShadow=true;
      if(node.material && (node.material.isMeshStandardMaterial||node.material.isMeshPhysicalMaterial)){
        node.material.onBeforeCompile = shader=>{
          shader.uniforms.time = { value: 0 };

          // Vertex Shader
          shader.vertexShader = `
            uniform float time;
            ${shader.vertexShader.replace(
              '#include <begin_vertex>',
              `
              vec3 transformed = vec3(position);
              transformed += normal * 0.05 * sin(time*3.0 + position.y*5.0);
              `
            )}
          `;

          // Fragment Shader (Rainbow Glow)
          shader.fragmentShader = `
            uniform float time;
            ${shader.fragmentShader.replace(
              '#include <dithering_fragment>',
              `
              gl_FragColor.rgb += 0.3 * vec3(
                0.5 + 0.5*sin(time + gl_FragCoord.x*0.05),
                0.5 + 0.5*sin(time + gl_FragCoord.y*0.05),
                0.5 + 0.5*sin(time)
              );
              #include <dithering_fragment>
              `
            )}
          `;

          node.userData.shader = shader;
        };
      }
    }
  });

  if(gltf.animations && gltf.animations.length){
    mixer = new THREE.AnimationMixer(model);
    gltf.animations.forEach(clip=>mixer.clipAction(clip).play());
  }

  model.position.set(-30,10,10);
  model.scale.set(50,50,50);
  scene.add(model);
});

  // Load model4 (ไม่มี Cel Shader)
  gltfLoader.load('https://boat445.github.io/homework/model4.glb', gltf=>{
    const model = gltf.scene || gltf.scenes[0];
    model.traverse(node=>{
      if(node.isMesh){
        node.castShadow=true; node.receiveShadow=true;
        if(node.material && (node.material.isMeshStandardMaterial||node.material.isMeshPhysicalMaterial)){
          node.material.envMap = envMap;
          node.material.needsUpdate = true;
        }
      }
    });
    if(gltf.animations && gltf.animations.length){
      mixer = new THREE.AnimationMixer(model);
      gltf.animations.forEach(clip=>mixer.clipAction(clip).play());
    }
    model.position.set(0,0,0);
    model.scale.set(0.02,0.02,0.02);
    scene.add(model);
  });

  // Load Jake (Cel Shader + Vertex Shader)
gltfLoader.load('https://boat445.github.io/homework/jake_el_perro.glb', gltf=>{
  const model = gltf.scene || gltf.scenes[0];
  model.traverse(node=>{
    if(node.isMesh){
      node.castShadow=true; node.receiveShadow=true;
      if(node.material && (node.material.isMeshStandardMaterial||node.material.isMeshPhysicalMaterial)){
        node.material.envMap = envMap;
        node.material.needsUpdate = true;

        // Cel + Vertex Shader
        node.material.onBeforeCompile = shader=>{
          shader.uniforms.time = { value: 0 };

          // Vertex Shader (realtime)
          shader.vertexShader = `
            uniform float time;
            ${shader.vertexShader.replace(
              '#include <begin_vertex>',
              `
              vec3 transformed = vec3(position);
              transformed += normal * 0.03 * sin(time*4.0 + position.y*10.0);
              `
            )}
          `;

          // Fragment Shader (Cel Shading)
          shader.fragmentShader = `
            uniform float time;
            ${shader.fragmentShader.replace(
              '#include <dithering_fragment>',
              `
              float intensity = dot(normalize(vNormal), vec3(0.0,1.0,0.0));
              if(intensity > 0.95) intensity = 1.0;
              else if(intensity > 0.5) intensity = 0.7;
              else if(intensity > 0.25) intensity = 0.4;
              else intensity = 0.1;
              gl_FragColor.rgb *= intensity;
              #include <dithering_fragment>
              `
            )}
          `;

          node.userData.shader = shader;
        };
      }
    }
  });

  if(gltf.animations && gltf.animations.length){
    mixer = new THREE.AnimationMixer(model);
    gltf.animations.forEach(clip=>mixer.clipAction(clip).play());
  }

  model.position.set(30,0,10);
  model.scale.set(3,3,3);
  scene.add(model);
});

  // Load texture cube
  const textureLoader = new THREE.TextureLoader();
  textureLoader.load('https://boat445.github.io/homework/poramet.jpg', (texture)=>{
    texture.encoding = THREE.sRGBEncoding;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    const cubeGeo = new THREE.BoxBufferGeometry(20,30,1);
    const cubeMat = new THREE.MeshStandardMaterial({ map: texture, metalness:0.3, roughness:0.7 });
    cubeMat.needsUpdate = true;
    const cube = new THREE.Mesh(cubeGeo, cubeMat);
    cube.position.set(30,20,-10);
    cube.castShadow = true; cube.receiveShadow = true;
    scene.add(cube);
  });

  // Resize
  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });

  // Animate
  (function animate(){
    const delta = clock.getDelta();
    if(mixer) mixer.update(delta);

    ball.rotation.y += 0.01;
    dir.position.x = 3 + Math.sin(clock.getElapsedTime())*1.0;

    // Update Finn shader time
    scene.traverse(obj=>{
      if(obj.isMesh && obj.userData.shader){
        obj.userData.shader.uniforms.time.value = clock.getElapsedTime();
      }
    });

    renderer.render(scene,camera);
    requestAnimationFrame(animate);
  })();
</script>
</body>
</html>
