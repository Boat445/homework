<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>Step 03 – MeshStandardMaterial (PBR, no GUI) • three.js r128</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>html,body{height:100%;margin:0} canvas{display:block}</style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
<script>


  // Scene / Camera / Renderer
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
  camera.position.set(0, 1.2, 3);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x333333, 0.6);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(3, 5, 2);
  dir.castShadow = true;
  scene.add(dir);

  // Ground
  const ground = new THREE.Mesh(
    new THREE.PlaneBufferGeometry(10, 10),
    new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.95, metalness: 0.0 })
  );
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Environment map (cube) สำหรับ reflection ของ PBR
 const cubeUrls = [
  'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg'
];
const envMap = new THREE.CubeTextureLoader().load(cubeUrls);
envMap.encoding = THREE.sRGBEncoding;
scene.background = envMap;  // <-- ใช้ cube map เป็น background
scene.environment = envMap; // <-- สำหรับสะท้อน PBR

 
  // Geometry + PBR Material
  const geo = new THREE.SphereBufferGeometry(0.65, 64, 64); // ทรงกลมทำให้เห็น reflection ชัด
  const mat = new THREE.MeshStandardMaterial({
    color: 0xffffff,  // สีฐาน
    metalness: 0.9,  // 0 = non-metal, 1 = metal
    roughness:  0.1,  // 0 = เรียบเงา, 1 = ด้าน
    envMap: envMap, // ใส่ที่วัสดุเพื่อใช้ envMapIntensity
    envMapIntensity:  1.0 // ความเข้มของแสงสะท้อนจาก env map
  });
  const ball = new THREE.Mesh(geo, mat);
  ball.position.y = 0.7;
  ball.castShadow = true;
  //scene.add(ball);

// Animation helpers
  const clock = new THREE.Clock();
  let mixer = null;

  // GLTF Loader — ตัวอย่างการโหลดไฟล์ models/scene.gltf
  const gltfLoader = new THREE.GLTFLoader();
  gltfLoader.load(
    'https://boat445.github.io/homework/poramet.glb', // เปลี่ยนเป็นพาธ/URL ของโมเดลของคุณ
    (gltf) => {
      const model = gltf.scene || gltf.scenes[0];
      model.traverse((node) => {
        if (node.isMesh) {
          node.castShadow = true;
          node.receiveShadow = true;
          // ถ้าวัสดุเป็น MeshStandardMaterial ให้ใช้ envMap ของฉากเพื่อสะท้อน
          if (node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)) {
            node.material.envMap = envMap;
            node.material.needsUpdate = true;
          }
        }
      });
      // Setup AnimationMixer and play animations (if any)
      if (gltf.animations && gltf.animations.length) {
        mixer = new THREE.AnimationMixer(model);
        // เล่นทุกคลิป — ถ้าต้องการเล่นแค่คลิปแรกใช้ mixer.clipAction(gltf.animations[0]).play();
        gltf.animations.forEach((clip) => {
          const action = mixer.clipAction(clip);
          action.play();
        });
      }
      model.position.set(30, 5, 0);
       model.scale.set(2,2,2);
      scene.add(model);
    },
    undefined,
    (error) => {
      console.error('Error loading glTF:', error);
    }
  );

 
  gltfLoader.load(
    'https://boat445.github.io/homework/home_monster.glb', // เปลี่ยนเป็นพาธ/URL ของโมเดลของคุณ
    (gltf) => {
      const model = gltf.scene || gltf.scenes[0];
      model.traverse((node) => {
        if (node.isMesh) {
          node.castShadow = true;
          node.receiveShadow = true;
          // ถ้าวัสดุเป็น MeshStandardMaterial ให้ใช้ envMap ของฉากเพื่อสะท้อน
          if (node.material && (node.material.isMeshStandardMaterial || node.material.isMeshPhysicalMaterial)) {
            node.material.envMap = envMap;
            node.material.needsUpdate = true;
          }
        }
      });
      // Setup AnimationMixer and play animations (if any)
      if (gltf.animations && gltf.animations.length) {
        mixer = new THREE.AnimationMixer(model);
        // เล่นทุกคลิป — ถ้าต้องการเล่นแค่คลิปแรกใช้ mixer.clipAction(gltf.animations[0]).play();
        gltf.animations.forEach((clip) => {
          const action = mixer.clipAction(clip);
          action.play();
        });
      }
      model.position.set(0, 0, 0);
      model.scale.set(0.1,0.1,0.1);
      scene.add(model);
    },
    undefined,
    (error) => {
      console.error('Error loading glTF:', error);
    }
  );
  // ...existing code...

// เพิ่ม Cube พร้อม Texture
const textureLoader = new THREE.TextureLoader();
textureLoader.load(
  'https://boat445.github.io/homework/poramet.jpg', // URL ของ texture
  function (texture) {
    const cubeGeometry = new THREE.BoxBufferGeometry(20, 30, 1);
    const cubeMaterial = new THREE.MeshStandardMaterial({
      map: texture,
      metalness: 0.3,
      roughness: 0.7
    });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    cube.position.set(30, 20, 10); // ตำแหน่งของ cube
    cube.castShadow = true;
    cube.receiveShadow = true;
    scene.add(cube);
  },
  undefined,
  function (err) {
    console.error('Error loading texture:', err);
  }
);

// ...existing code...

  // Resize
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
  

  // Animate
  let t = 0;
  (function loop(){
const delta = clock.getDelta();
    if (mixer) mixer.update(delta); 

    t += 0.01;
    ball.rotation.y += 0.01;
    dir.position.x = 3 + Math.sin(t) * 1.0; // ขยับไฟนิดหน่อยให้ไฮไลต์เปลี่ยน
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  })();
</script>
</body>
</html>
