<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PBR Viewer — Three.js (with GLB download)</title>
  <style>
    /* (same styles as original, omitted here for brevity in the canvas view) */
    /* For clarity: keep the original CSS from your index.html */
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <canvas id="c"></canvas>

  <!-- Toolbar: added Download button -->
  <div class="toolbar" style="left:16px; top:16px;">
    <button id="downloadGLB" class="btn">ดาวน์โหลด GLB</button>
  </div>

  <!-- (rest of HTML UI from original file) -->
  <button id="toggleSimple" class="setting-btn">Setting</button>
  <div id="simplePanel" class="setting-panel" aria-hidden="true"> ... (same as original) ... </div>
  <div class="dock"> ... </div>
  <div id="toast" class="toast" aria-live="polite"></div>
  <div id="ffHint" class="ff-hint" aria-hidden="false"></div>
  <div id="panel" class="panel" aria-hidden="true"> ... </div>
  <div class="credit">Built with Three.js + lil‑gui</div>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
  import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
  import GUI from 'https://unpkg.com/lil-gui@0.18/dist/lil-gui.esm.js';

  // --- Renderer ---
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  // --- Scene / Camera / Controls ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0f16);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 300);
  camera.position.set(2.8, 1.8, 3.2);

  const controls = new OrbitControls(camera, renderer.domElement);
  const fp = new PointerLockControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.minDistance = 0.6;
  controls.maxDistance = 25;
  const defaultCam = camera.position.clone();
  const defaultTarget = new THREE.Vector3(0,0,0);

  // --- PMREM & HDRi ---
  const pmrem = new THREE.PMREMGenerator(renderer);
  let envRT = null; // PMREM render target

  function setEnvironmentFromEquirect(tex){
    if (envRT) envRT.dispose();
    envRT = pmrem.fromEquirectangular(tex);
    const envMap = envRT.texture;
    scene.environment = envMap;
    if (params.showBackground) scene.background = envMap; else scene.background = new THREE.Color(0x0b0f16);
    tex.dispose();
  }

  function loadHDRI(path){
    return new Promise((resolve, reject)=>{
      new RGBELoader().load(path, (hdrTex)=>{ setEnvironmentFromEquirect(hdrTex); resolve(hdrTex); }, undefined, (err)=>{ console.warn('HDRi load failed', err); reject(err); });
    });
  }

  // --- Lights ---
  const hemi = new THREE.HemisphereLight(0xffffff, 0x11121a, 0.25);
  scene.add(hemi);
  const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
  dirLight.position.set(3,5,3);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(2048, 2048);
  dirLight.shadow.normalBias = 0.02;
  scene.add(dirLight);

  const spotLight = new THREE.SpotLight(0xffffff, 0.0);
  spotLight.position.set(-2, 4, 2);
  spotLight.angle = Math.PI/6;
  spotLight.penumbra = 0.25;
  spotLight.decay = 2;
  spotLight.distance = 0;
  spotLight.castShadow = true;
  spotLight.shadow.mapSize.set(1024,1024);
  spotLight.visible = false;
  scene.add(spotLight);

  // --- Ground & Grid ---
  const textureLoader = new THREE.TextureLoader();
  const groundTexture = textureLoader.load('ground3.jpg');
  groundTexture.wrapS = THREE.RepeatWrapping;
  groundTexture.wrapT = THREE.RepeatWrapping;
  groundTexture.repeat.set(4, 4);

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(10, 10),
    new THREE.MeshStandardMaterial({ map: groundTexture, roughness: 0.9, metalness: 0.0 })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // --- GLB Loading ---
  const gltfLoader = new GLTFLoader();
  const exporter = new GLTFExporter();
  let models = []; // เก็บ models ที่โหลดมา

  function centerAndFloor(obj){
    const box = new THREE.Box3().setFromObject(obj);
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = maxDim > 0 ? 1.6 / maxDim : 1.0;
    obj.scale.setScalar(scale);

    const box2 = new THREE.Box3().setFromObject(obj);
    const center = box2.getCenter(new THREE.Vector3());
    const minY = box2.min.y;
    obj.position.x += -center.x;
    obj.position.z += -center.z;
    obj.position.y += -minY;
  }

  function applyPBR(root){
    root.traverse(o=>{
      if (o.isMesh){
        o.castShadow = true;
        o.receiveShadow = false;
        if (!o.material || (!o.material.isMeshStandardMaterial && !o.material.isMeshPhysicalMaterial)){
          o.material = new THREE.MeshStandardMaterial({ color:0xcfd5e2, metalness:0.2, roughness:0.5 });
        }
      }
    });
  }

  function loadGLB(path){
    return new Promise((resolve, reject)=>{
      gltfLoader.load(path, (gltf)=>{
        const newModel = gltf.scene;
        applyPBR(newModel);
        centerAndFloor(newModel);

        if (path.includes('model6.glb')) {
          newModel.scale.multiplyScalar(3);
        }

        const offset = models.length * 2;
        newModel.position.x += offset;

        scene.add(newModel);
        models.push(newModel);
        updateDownloadButtonState();
        resolve(newModel);
      }, undefined, (err)=>{ console.error('GLB load failed', err); reject(err); });
    });
  }

  // --- Drag & Drop support ---
  addEventListener('dragover', (e)=>{ e.preventDefault(); });
  addEventListener('drop', (e)=>{
    e.preventDefault();
    const files = [...e.dataTransfer.files];
    const hdr = files.find(x=>/\.hdr$/i.test(x.name));
    const glb = files.find(x=>/\.glb$/i.test(x.name));

    if (hdr){
      const u = URL.createObjectURL(hdr);
      loadHDRI(u).finally(()=> URL.revokeObjectURL(u));
    }
    if (glb){
      const u = URL.createObjectURL(glb);
      loadGLB(u).finally(()=> URL.revokeObjectURL(u));
    }
  });

  // --- Download GLB logic ---
  // This will export all loaded models combined into one GLB binary file.
  function downloadCombinedGLB(filename = 'scene.glb'){
    if (!models.length) { showToast('ยังไม่มีโมเดลให้ดาวน์โหลด'); return; }

    // Clone models into a temporary group so we don't modify original scene transforms
    const exportGroup = new THREE.Group();
    models.forEach(m => exportGroup.add(m.clone(true)));

    const options = { binary: true, truncateDrawRange: true };
    exporter.parse(exportGroup, function(result){
      // result is ArrayBuffer when binary:true
      if (result instanceof ArrayBuffer){
        const blob = new Blob([result], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        showToast('เริ่มดาวน์โหลด ' + filename);
      } else {
        showToast('การสร้าง GLB ล้มเหลว (ไม่ใช่ binary)');
      }
    }, options);
  }

  const downloadBtn = document.getElementById('downloadGLB');
  downloadBtn.addEventListener('click', ()=> downloadCombinedGLB('my_models.glb'));

  function updateDownloadButtonState(){
    if (!downloadBtn) return;
    downloadBtn.disabled = models.length === 0;
    downloadBtn.title = models.length ? `${models.length} model(s) ready to download` : 'ไม่มีโมเดล';
  }

  // --- rest of UI wiring, GUI and controls (same as original) ---
  // For brevity, reuse the rest of your original JS (GUI setup, controls, render loop)

  // ... (the rest of the original script should be pasted here unchanged) ...

  // For demonstration we keep the original start sequence but ensure updateDownloadButtonState is called
  (async function start(){
    try{ await loadHDRI('pic2.hdr'); } catch(e){ console.warn('Using dark background (no HDRi)'); }
    try{ await loadGLB('model4.glb'); } catch(e){ console.warn('No default GLB found'); }
    try { await loadGLB('model6.glb'); } catch(e){ console.warn('ไม่เจอ model4.glb'); }
    updateDownloadButtonState();
  })();

  // --- Resize & Render loop placeholder ---
  addEventListener('resize', ()=>{ renderer.setSize(innerWidth, innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); });

  const clock = new THREE.Clock();
  renderer.setAnimationLoop(()=>{ const dt = clock.getDelta(); renderer.render(scene, camera); });

  </script>
</body>
</html>
